const express = require("express");
const amqp = require("amqplib/callback_api");
const path = require("path");
const { EventEmitter } = require("events");
const session = require("express-session");

const app = express();
const Event = new EventEmitter();

app.set("view engine", "ejs");
app.set("views", "views");
app.use(express.json());
app.use(
  session({
    secret: "this is a secret",
    resave: false,
    saveUninitialized: false,
  })
);
app.use(express.urlencoded({ extended: true }));

const pagesRoutes = require("./routes/pages");

amqp.connect("amqp://localhost", (err, connection) => {
  if (err) {
    throw err;
  }

  connection.createChannel((err, channel) => {
    if (err) {
      throw err;
    }

    //I am using a RPC (request-reply) pattern, so this is our only queue, the name is generated by
    //RabbitMQ and passed as the parameter 'replyQueue'
    channel.assertQueue("", { exclusive: true }, (err, replyQueue) => {
      if (err) {
        throw err;
      }

      //generating a correlationId to identify requests
      const correlationId = String(
        Math.random() + Math.random() + Math.random()
      );

      //consuming the reply and emitting an event containing the response
      channel.consume(
        replyQueue.queue,
        (data) => {
          if (data.properties.correlationId == correlationId) {
            console.log("Emmiting event..");
            Event.emit(data.properties.correlationId.toString(), data);
          }
        },
        {
          noAck: true,
        }
      );

      //defining app's routes
      app.use(express.static(path.join(__dirname, "public")));

      app.get("/", (req, res) => {
        res.redirect("/pages/home");
      });

      app.get("/pages/shop", (req, res) => {
        const data = JSON.stringify({
          operation: "get-cart",
          email: req.session.email,
        });

        channel.sendToQueue("rpc_queue", Buffer.from(data), {
          correlationId: correlationId,
          replyTo: replyQueue.queue,
          headers: {
            function: data.operation,
          },
        });

        Event.once(correlationId, (data) => {
          const responseParsed = JSON.parse(data.content.toString());
          if (responseParsed.status == "ERROR") {
            res.render("pages/shop", {
              error: null,
              isLoggedIn: req.session.isLoggedIn,
              route: "pages/shop",
              cart: 0,
            });
            return;
          }

          console.log(responseParsed);

          res.render("pages/shop", {
            error: null,
            isLoggedIn: req.session.isLoggedIn,
            route: "pages/shop",
            cart: responseParsed.data,
          });
          return;
        });

        console.log(
          "we are here",
          req.session,
          req.session.email,
          req.session.isLoggedIn
        );
      });

      //GET routes that just render new pages
      app.use("/pages", pagesRoutes);

      //POST routes
      app.post("/pages/login", (req, res, next) => {
        const email = req.body.email.trim();
        const password = req.body.password.trim();

        //data validation
        if (!email.includes("@")) {
          res.render("pages/login", {
            error: {
              message: "Please enter a valid email",
              type: "login",
            },
          });
          return;
        }

        if (password.length < 6) {
          res.render("pages/login", {
            error: {
              message: "Password must be longer than six digits",
              type: "login",
            },
          });
          return;
        }

        const data = JSON.stringify({ email, password, operation: "login" });

        //sending request to the server
        channel.sendToQueue("rpc_queue", Buffer.from(data), {
          correlationId: correlationId,
          replyTo: replyQueue.queue,
          headers: {
            function: data.operation,
          },
        });

        //listening to the event emitted by the reply queue and executing code for errors or sucess
        Event.once(correlationId, (data) => {
          const responseParsed = JSON.parse(data.content.toString());
          if (responseParsed.status == "ERROR") {
            res.render("pages/login", {
              error: {
                message: responseParsed.message,
                type: responseParsed.type,
              },
            });
          }
          req.session.isLoggedIn = true;
          req.session.email = email;
          res.redirect("/pages/shop");
        });
      });

      app.post("/pages/signup", async (req, res, next) => {
        const email = req.body.email.trim();
        const confirm = req.body.confirm.trim();
        const password = req.body.password.trim();

        //data validation
        if (!email.includes("@")) {
          res.render("pages/login", {
            error: {
              message: "Please enter a valid email",
              type: "signup",
            },
          });
          return;
        }

        if (password.length < 6) {
          res.render("pages/login", {
            error: {
              message: "Password must be longer than six digits",
              type: "signup",
            },
          });
          return;
        }

        if (password !== confirm) {
          res.render("pages/login", {
            error: {
              message: "Passwords must match",
              type: "signup",
            },
          });
          return;
        }

        const data = JSON.stringify({
          email,
          password,
          confirm,
          operation: "signup",
        });

        //sending request to the server
        channel.sendToQueue("rpc_queue", Buffer.from(data), {
          correlationId: correlationId,
          replyTo: replyQueue.queue,
          headers: {
            function: data.operation,
          },
        });

        //listening to the event emitted by the reply queue and executing code for errors or sucess
        Event.once(correlationId, (data) => {
          const responseParsed = JSON.parse(data.content.toString());
          if (responseParsed.status == "ERROR") {
            res.render("pages/login", {
              error: {
                message: responseParsed.message,
                type: responseParsed.type,
              },
            });
          }
          req.session.isLoggedIn = true;
          req.session.email = email;
          res.render("pages/shop", {
            error: null,
            isLoggedIn: req.session.isLoggedIn,
            route: "pages/shop",
            cart: responseParsed.data,
          });
        });
      });

      app.post("/logout", (req, res) => {
        req.session.isLoggedIn = false;
        req.session.email = null;
        res.render("pages/shop", {
          isLoggedIn: req.session.isLoggedIn,
          route: "pages/shop",
        });
      });

      app.post("/add-product", (req, res) => {
        if (!req.session.isLoggedIn) {
          res.redirect("/pages/login");
          return;
        }

        const data = JSON.stringify({
          operation: "add-product",
          email: req.session.email,
        });

        channel.sendToQueue("rpc_queue", Buffer.from(data), {
          correlationId: correlationId,
          replyTo: replyQueue.queue,
          headers: {
            function: data.operation,
          },
        });

        Event.once(correlationId, (data) => {
          res.redirect("/pages/shop");
        });
      });

      app.listen(3000, () => console.log("server running"));
    });
  });
});
